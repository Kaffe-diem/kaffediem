---
title: Create Database Migration
description: Create and manage database schema changes in Kaffediem using Ecto migrations with examples and best practices.
---

## When to Use This

You need to:
- Add a new table
- Add/remove/modify columns
- Add indexes or constraints
- Migrate data between schema versions

## Quick Start

```bash
cd kaffebase
mix ecto.gen.migration migration_name
```

This creates a timestamped file in `priv/repo/migrations/`.

## Basic Patterns

### Create a New Table

```elixir
defmodule Kaffebase.Repo.Migrations.CreateReviews do
  use Ecto.Migration

  def change do
    create table(:reviews, primary_key: false) do
      add :id, :string, primary_key: true
      add :rating, :integer, null: false
      add :comment, :text
      add :order_id, :string, null: false

      timestamps(type: :utc_datetime_usec)
    end

    create index(:reviews, [:order_id])
  end
end
```

Run with:

```bash
mix ecto.migrate
```

### Add a Column

```elixir
defmodule Kaffebase.Repo.Migrations.AddPhoneToUsers do
  use Ecto.Migration

  def change do
    alter table(:users) do
      add :phone, :string
    end
  end
end
```

### Remove a Column

```elixir
defmodule Kaffebase.Repo.Migrations.RemoveObsoleteField do
  use Ecto.Migration

  def change do
    alter table(:orders) do
      remove :old_field
    end
  end
end
```

### Rename a Column

```elixir
defmodule Kaffebase.Repo.Migrations.RenameUserColumn do
  use Ecto.Migration

  def change do
    rename table(:users), :username, to: :display_name
  end
end
```

### Add an Index

```elixir
defmodule Kaffebase.Repo.Migrations.AddOrderStateIndex do
  use Ecto.Migration

  def change do
    create index(:order, [:state])
    create index(:order, [:customer_id, :inserted_at])  # Composite index
  end
end
```

### Add a Unique Constraint

```elixir
defmodule Kaffebase.Repo.Migrations.UniqueItemName do
  use Ecto.Migration

  def change do
    create unique_index(:item, [:name])
  end
end
```

## Kaffediem Conventions

### Primary Keys

Use **string IDs** for domain entities:

```elixir
create table(:entity_name, primary_key: false) do
  add :id, :string, primary_key: true
  # ...
end
```

IDs are generated by `Kaffebase.Ids.generate()` (nanoid format).

### Timestamps

Always use microsecond precision:

```elixir
timestamps(type: :utc_datetime_usec)
```

This ensures consistency with Phoenix defaults.

### JSONB Fields

For storing structured data:

```elixir
add :items_data, :text  # SQLite stores as TEXT
```

Access in Ecto with custom types:

```elixir
field :items, JsonbItems, source: :items_data
```

### Foreign Keys

Reference by string ID:

```elixir
add :category, :string, null: false
# No foreign key constraint - denormalized design
```

Or use actual foreign keys:

```elixir
add :user_id, references(:users, type: :string, on_delete: :delete_all)
```

## Advanced Patterns

### Conditional Migration

Only create if doesn't exist:

```elixir
def change do
  create_if_not_exists table(:my_table) do
    # ...
  end
end
```

### Data Migration

Transform existing data:

```elixir
defmodule Kaffebase.Repo.Migrations.MigrateOrderFormat do
  use Ecto.Migration
  import Ecto.Query

  def up do
    # Add new column
    alter table(:orders) do
      add :new_format, :text
    end

    # Transform data
    flush()  # Ensure schema changes are applied

    execute(fn ->
      repo().query!("""
        UPDATE orders
        SET new_format = json_transform(old_format)
        WHERE old_format IS NOT NULL
      """)
    end)

    # Remove old column
    alter table(:orders) do
      remove :old_format
    end
  end

  def down do
    # Reverse the migration
    alter table(:orders) do
      add :old_format, :text
    end

    flush()

    execute(fn ->
      repo().query!("""
        UPDATE orders
        SET old_format = reverse_transform(new_format)
        WHERE new_format IS NOT NULL
      """)
    end)

    alter table(:orders) do
      remove :new_format
    end
  end
end
```

### Separate Up/Down

For irreversible changes:

```elixir
def up do
  drop table(:obsolete_table)
end

def down do
  raise "Cannot recreate dropped table"
end
```

## Migration Workflow

### Create Migration

```bash
mix ecto.gen.migration your_migration_name
```

### Check Migration Status

```bash
mix ecto.migrations
```

### Run Migrations

```bash
# Run all pending migrations
mix ecto.migrate

# Run up to a specific version
mix ecto.migrate --to 20251020080000
```

### Rollback

```bash
# Rollback last migration
mix ecto.rollback

# Rollback last 3 migrations
mix ecto.rollback --step 3

# Rollback to specific version
mix ecto.rollback --to 20251020080000
```

### Reset Database

```bash
# Drop, create, migrate, seed
mix ecto.reset
```

## Testing Migrations

### In Development

```bash
# Run migration
mix ecto.migrate

# Test it works
iex -S mix

# Rollback to test down function
mix ecto.rollback

# Re-run
mix ecto.migrate
```

### In Tests

Migrations run automatically in test environment:

```bash
MIX_ENV=test mix ecto.migrate
mix test
```

## SQLite Specifics

SQLite has some limitations compared to PostgreSQL:

### Limited ALTER TABLE

Cannot:
- Drop columns in older SQLite versions (workaround: recreate table)
- Change column types directly
- Add constraints to existing columns

Workaround for dropping columns:

```elixir
def change do
  execute("""
    CREATE TABLE new_table AS
    SELECT id, keep_column1, keep_column2
    FROM old_table
  """)

  execute("DROP TABLE old_table")
  execute("ALTER TABLE new_table RENAME TO old_table")
end
```

### No Array Types

Use TEXT fields with JSON:

```elixir
add :tags, :text  # Store as JSON: ["tag1", "tag2"]
```

## Best Practices

- **One logical change per migration**: Easier to understand and rollback
- **Always test rollback**: Implement `down` or separate `up`/`down`
- **Use `change` when possible**: Ecto can auto-reverse many operations
- **Add indexes for foreign keys**: Improves query performance
- **Set `null: false` where appropriate**: Enforce data integrity
- **Use transactions implicitly**: Ecto wraps migrations in transactions
- **Coordinate with team**: Avoid migration conflicts

## Checklist

- ✅ Migration file created with descriptive name
- ✅ `change` function (or `up`/`down`) implemented
- ✅ Indexes added for frequently queried columns
- ✅ Constraints (null, unique) applied where needed
- ✅ Timestamps added to new tables
- ✅ Migration tested (run and rollback)
- ✅ Ecto schemas updated to match
- ✅ Related code updated (controllers, contexts)

## Common Issues

### Migration Already Run

If you need to modify:

```bash
# Rollback
mix ecto.rollback

# Edit the migration file

# Re-run
mix ecto.migrate
```

**Never edit a migration that's been deployed to production!** Create a new one instead.

### Migration Fails

Check:
- Syntax errors in SQL
- References to non-existent tables/columns
- Constraint violations in existing data

Debug with:

```bash
mix ecto.migrate --log-sql
```

### Can't Rollback

If rollback fails, you may need to manually fix:

```bash
iex -S mix

# Check migration status
Ecto.Migrator.migrations(Kaffebase.Repo)

# Manually run down
Kaffebase.Repo.query!("DROP TABLE problem_table")
```

## Next Steps

- [Add New Collection](/dev/how-to/add-new-collection) - Full stack example
- [Database Schema Reference](/dev/reference/database-schema) - All tables
- [Ecto Documentation](https://hexdocs.pm/ecto_sql/Ecto.Migration.html) - Official docs
